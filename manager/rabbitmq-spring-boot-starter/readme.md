### mq 最佳实践

使用 mq 时，我们需要保证业务处理和消息处理的一致性，会面临以下问题：

1. 业务成功之后，再发 q
2. 发 q 要保证消息投递成功
3. 消息要能在 broker 上面持久化
4. 消费者只消费一次

#### 开发层面

**发送方**

一种方案是等事务提交之后，再发 q，这个可以通过 TransactionSynchronizationManager 来完成，但是如果重试的过程中宕机的话，
会导致该条消息丢失

一种方案是将要发的事件存储到数据库，后续通过定时器来发 q，这种方案因为事件和业务在一个事务里面，所以通过重试一定能够保证发 q
成功，就算宕机了，消息也是存储在数据库里面。这种实现起来有点繁琐，一般用第一种方式就行了

**持久化消息**

通过持久化 exchange、queue、message 即可

**手动消费确认**

手动消费确认主要是防止消费过程中消费方的宕机，而不是消费失败。像消费失败这种，最好是消费方自己处理，而不是重新投递

**幂等消费**

if null add 的模型

****

**路由策略**

* 每个模块一个 topic exchange

#### 运维层面





#### 参考

[RabbitMQ 最佳实践](https://www.cnblogs.com/davenkin/p/rabbitmq-best-practices.html)
